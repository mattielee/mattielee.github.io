document.addEventListener('DOMContentLoaded', function () {
    const cards = document.querySelectorAll('.card');
    const popupOverlay = document.getElementById('popupOverlay');
    const popupContent = document.getElementById('popupContent');
    const closeButton = document.getElementById('closeButton');
    const popupInnerContent = document.getElementById('popupInnerContent');

    const popupContents = {
        1: {
            html: `
                <h3>
                    Floating Point Library [C2S2]
                </h3>
                <ul class="skills">
                    <li>SystemVerilog</li>
                    <li>ASIC Design Flow</li>
                    <li>Register Retiming</li>
                    <li>Floating Point Arithmetic</li>
                    <li>OpenLane</li>
                    <li>Yosys</li>
                    <li>ABC</li>
                </ul>
                <p><i>in progress!</i> Check out our <a href="https://c2s2.engineering.cornell.edu/blogposts/FA23/RepresentingNumbersInHardware" target="_blank"><b>blog post</b></a> on hardware representations of numbers! </p>
                <img src="assets/c2s2-work.jpg">
                <p>
                    I am currently working with a partner on integrating a floating point library into the C2S2 IP. 
                    After realizing the complexities of writing our own floating point arithmetic blocks from scratch, 
                    we decided to opt for an open-source library instead. We are currently exploring 
                    <a href="http://www.jhauser.us/arithmetic/HardFloat.html" target="_blank"><b>Berkeley’s HardFloat</b></a>  
                    library. I created a <a href="https://pymtl3.readthedocs.io/en/latest/index.html" target="_blank"><b>pyMTL</b></a> 
                    testbench that pipes in test cases generated by 
                    <a href="http://www.jhauser.us/arithmetic/TestFloat.html" target="_blank"><b>Berkeley’s TestFloat</b></a> 
                    library to thoroughly test the floating point blocks. PyMTL is a domain-specific framework created by Professor Christopher Batten’s 
                    research group that allows RTL designers to leverage Python’s computational power to create robust behavioral 
                    models for RTL verification. PyMTL is an example of a research frontier in the chip design field that focuses 
                    on making chip design easier and more accessible through design-specific frameworks and high-level synthesis. 
                    If I pursue a master’s degree, this is what I would like to focus my research on!<br><br>
                    Berkeley’s HardFloat library is mostly combinational. This means that to meet the timing requirements of our design, 
                    we will need to pipeline these combinational modules. Most commercial tools support <b>register retiming,</b> which 
                    automatically moves pipeline registers to the most optimal points of the design to meet a specific clock frequency. 
                    This is done in the synthesis stage of the ASIC flow. However, since we use open-source tools, we had to explore 
                    whether or not our tools supported register retiming. <br><br>
                    On C2S2, we use the 
                    <a href="https://openlane.readthedocs.io/en/latest/" target="_blank"><b>OpenLane</b></a> 
                    flow, which in turn, uses <a href="https://yosyshq.readthedocs.io/projects/yosys/en/latest/index.html" target="_blank"><b>Yosys</b></a> 
                    and <a href="https://people.eecs.berkeley.edu/~alanmi/abc/abc.htm" target="_blank"><b>ABC</b></a> as its synthesis tools. 
                    Although ABC does support register retiming, this option is not yet integrated into the OpenLane user interface 
                    (config files). Thus, to run register retiming on our designs, we have to hack the OpenLane tcl files to include 
                    the correct ABC option. <br><br>
                    Our next steps for this project include verifying that register retiming works through continuous runs and 
                    analysis of the timing reports, continuing to verify the HardFloat behavior through the pyMTL testbench, 
                    and including some of the floating point blocks on a tape out in Spring 2024. <br><br>
                    So far, I have learned a lot about the ASIC flow through this project. Before, I did not know what register 
                    retiming was and did not understand the OpenLane flow or how the tool utilized other open-source tools. 
                    I am also learning a lot about floating point and the IEEE standard. 
                    <br><br>
                    Image source:<br> <i> https://yhan.dev/intel-pin-dynamic-binary-analysis-tool/ </i>
                </p>
            `,
        },
        2: {
            html: `
                <h3>
                    Mode Stirring Antennas [Research] 
                </h3>
                <ul class="skills">
                    <li>PCB Design</li>
                    <li>RF Circuits</li>
                    <li>Embedded Systems</li>
                </ul>
                <p><i>Check out my <a href="https://ieeexplore.ieee.org/document/10178597" target="_blank"><b>co-authored paper</b></a>
                published in the 2023 IEEE International Conference on RFID!</i></p>
                <img src="assets/mode_stirring_card.jpg">
                <p>
                While working part-time in Professor Matt Reynolds’ lab in the Summer of 2022, I designed and assembled 2 PCBs 
                for 2.4GHz mode stirring antennas. <br><br>
                These PCBs control the termination of two antenna feed points (vertical and horizontal polarizations), 
                using an RF switch to switch between an open and short circuit. These termination circuits control the 
                phase shift of the reflected signal by 180 degrees. The purpose of these antennas is to decrease the deep 
                nulls in communication signals caused by destructive interference in a metal cage. By using multiple antennas 
                configured outside of a reverberant metal cage, there is an optimal configuration of the antennas such that 
                the deep nulls within the cage are minimized. <br><br>
                I also created a Python script that interfaced with an Arduino using the Telemetrix library to control the RF 
                switches on the PCB. The script cycled through all configurations of up to 8 antennas, allowing for automated 
                testing of antenna configurations.<br><br>
                I co-authored a paper that detailed this work (linked above) and am currently volunteering remotely on a 
                part-time basis for Professor Reynolds to co-author another paper containing an update on the configuration 
                automation system. 
                </p>
            `,
        },
        3: {
            html: `
                <h3>
                    Multicore Processor [Course Lab] 
                </h3>
                <ul class="skills">
                    <li>Computer Architecture</li>
                    <li>SystemVerilog</li>
                    <li>Python</li>
                </ul>
                <p>My lab reports for each subsection of this project are linked 
                <a href="https://drive.google.com/drive/folders/1a9VearQ8Az7GlX7MF-qc98Le4uD5eIce?usp=sharing" target="_blank"><b>here!</b></a> </p>
                <img src="assets/comparch-oh.jpg">
                <p>
                I designed and implemented a quad-core processor with a simple ring network, private instruction caches, 
                and a shared, banked data cache. The design utilized a control/datapath design methodology across all submodules. 
                The processor was a 5-stage pipelined processor, capable of performing a subset of RISC-V instructions, with stalling 
                and bypassing logic to resolve data hazards. Caches were two-way set associative, write-back, write-allocate. 
                I used the pyMTL3 design-specific framework to generate over 1000 test cases to verify the design. 
                </p>
            `,
        },
        4: {
            html: `
            <h3>
                Packet Sampler [SpaceX] 
            </h3>
            <ul class="skills">
                <li>SystemVerilog</li>
                <li>FPGA Design Flow</li>
            </ul>
            <p></p>
            <img src="assets/fpga-design-flow.jpg">
            <p>
            This project taught me a lot about the FPGA design flow. Previous to this experience, 
            I had only worked with RTL and behavioral simulation. This project exposed me to synthesis, implementation, 
            place and route, and validation of the logic after it was programmed onto the actual hardware. 
            Unfortunately, I cannot go into detail about the technical implementation of my design because it is under NDA. <br><br>
            Image sources: <br><i> https://hardwarebee.com/understanding-fpga-programming-and-design-flow/ <br>
            https://www.forbes.com/sites/jonathanocallaghan/2020/04/21/what-are-those-strange-moving-lights-in-the-night-sky-elon-musks-starlink-satellites-explained/?sh=14a25e4e7cbc
            </i>
            </p>
            `,
        },
        5: {
            html: ` 
            <h3>
                Robotic Arm Color Sorter [Course Lab]
            </h3>
            <ul class="skills">
                <li>Computer Vision</li>
                <li>Inverse Kinematics</li>
                <li>Embedded Operating Systems</li>
                <li>Python</li>
                <li>Linux</li>
            </ul>
            <p>Check out the project website to see a video of the robot in action as well as a more in depth discussion of this project!</p>
            <img src="assets/5725-team.jpg">
            <p>
                Using a Raspberry Pi, this project utilizes the PiCamera for color detection of various fruits 
                (as puff balls) using OpenCV. Once the fruit is identified, the meArm robotic arm uses inverse 
                kinematics to sort them into different bins, by enabling precise control of its servo motors. 
                The code also incorporates GPIO event handling, allowing the user to exit the program or shut 
                down the Raspberry Pi using external buttons.
            </p>
            `,
        },
    };

    cards.forEach((card) => {
        card.addEventListener('click', function () {
            const dataIndex = card.getAttribute('data-index');
            const content = popupContents[dataIndex];

            if (content && content.html) {
                popupInnerContent.innerHTML = content.html;

                // Show the popup
                popupOverlay.style.display = 'flex';
            }
        });
    });

    closeButton.addEventListener('click', function () {
        // Close the popup when the close button is clicked
        popupOverlay.style.display = 'none';
    });

    popupOverlay.addEventListener('click', function (event) {
        // Close the popup when clicking outside the popup content
        if (event.target === popupOverlay) {
            popupOverlay.style.display = 'none';
        }
    });
});
